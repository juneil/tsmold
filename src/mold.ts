import Ajv from 'ajv';
import { SCHEMA } from './constants';
import { extractSchema } from './builder';

export class Molder {
    /**
     * instantiate
     *
     * Instantiate a class with using ajv to
     * validate and tranform the payload.
     * The validated payload will populate the instance.
     *
     * Example:
     *
     * class Account {
     *      @Required
     *      balance: integer;
     * }
     *
     * const instance = Molder.instantiate(Account, { balance: '1000', extraInfo: 'xxx' });
     *
     * instance: Account { balance: 1000 }
     *
     * @param token
     * @param payload
     */
    static instantiate<T>(token: { new (): T }, payload: any): T {
        const instance = Reflect.construct(token, []);
        Object.entries(this.validate(token, payload)).forEach(([key, value]) => {
            instance[key] = value;
        });
        return instance;
    }

    /**
     * validate
     *
     * Use ajv to validate and tranform the payload.
     *
     * @param token
     * @param payload
     */
    static validate<T extends Function>(token: T, payload: any): any {
        const value = this.getCompiledSchema(token)(payload);
        if (!value) {
            throw new Error(new Ajv().errorsText(this.getCompiledSchema(token).errors));
        }
        return payload;
    }

    /**
     * getCompiledSchema
     *
     * Getter for the compiled schema generated by ajv.
     * The compile will be generated at the first call and
     * stored in the class metadata. The next calls will get
     * the compiled schema directly in the metadata.
     *
     * @param token
     */
    private static getCompiledSchema(token: Function): Ajv.ValidateFunction {
        let compiledSchema = Reflect.getMetadata(SCHEMA, token);
        if (!compiledSchema) {
            const ajv = Ajv({ removeAdditional: true, useDefaults: true, coerceTypes: true });
            const schema = extractSchema(token);
            compiledSchema = ajv.compile(schema);
            Reflect.defineMetadata(SCHEMA, compiledSchema, token);
        }
        return compiledSchema;
    }
}
